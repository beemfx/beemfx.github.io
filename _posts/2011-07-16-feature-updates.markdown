---
layout: post
title: "Feature Updates"
date: 2011-07-16 20:53:00 +0000
---
With the engine coming along nicely, I have now been working on graphic updates. Vertex and Pixel shaders are more strongly implemented in the game, and I have written another internal HLSL file &lt;lightf.fx&gt; that has some typical lighting calculation functions as well as a vertex and pixel shader that implements those lightings. I did this because more and more I see reasons to strictly use vertex shaders for all rendering. I've been working with vertex blending (or vertex skinning) within the vertex shader instead of in software. Vertex blending is the process of animating a mesh, and because of the way vertex shaders work, it seems like the best result will be to do everything in a vertex shader. Previously a lot of effects could be accomplished using the standard Direct3D render states and pipeline, but this is seeming more and more obsolete. I also added the material to the shader model. Most of the lighting code is based upon Lengyel's Mathematics for 3D Game Programming book, but with the emissive and ambient components implemented similar to the way Direct3D does it by default.

I also fixed some major problems with the way the server communicated with the client that should prevent some thread stalls that were occuring. This also solved a problem where if the client ran too fast, most of the messages to the server would be skipped. This made it so the game can now be run without vsync enabled. Also, the way input was sent to the server has been changed, so that it is now concatenated until the server retrieves it. Speaking of which, what I really want to do is run a second physics simulation on the client that only computes the behavior of the client's entity. Then sends that behavior to the server, the server running some kind of predictor corrector method. This would eliminate the need of sending input to the server at all, as that would only be processed on the client side. It should allow a faster response between the client and movement of the entity it is controlling. Albeit, the lag between controls and response is hardly noticeable when the server and the client are on the same machine, but when I actually begin to implement networking this is probably an important thing to do.

In other news I finally got around to clearing up all the memory leaks that were occurring in the game. I say finally because they were bugging me for a while now, and though the leaks were small, I felt that they had the potential to blow up. Most of the leaks were caused by declaring static objects that allocated memory in their constructors. A few were caused by failing to deallocate memory in some other capacity.

Overall I'm very happy with how the game is coming along. I've also begun to develop a map for an actual game. I won't announce what the game is simple because it is a really simple idea, and it is a really good idea, and I don't want anyone to steal the idea. While Ideally I'd like to work on a Deus Ex clone, an adventure game, or something else with a lot of story, I just don't have the resources to do so, so I'm going to be focusing on developing a more casual type game. Something that I can probably develop on my own. The biggest problem there is that I have to really learn how to do some decent art, and not all this programmer art that I have been doing.

Most of the work I plan on doing on the engine will be in the graphics department. I want to implement dot3 bump mapping, perfect the shadows, and add real time reflections. Other than that, there is still a bug where the game will crash if client tries to connect to a server where no map or entity definition file has been loaded. I know exactly what is causing this, but it involves work on both the server and client so I haven't dealt with it yet.
